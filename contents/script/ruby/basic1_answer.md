# Ruby ― 基本編 I 演習問題解答

## 演習問題 1

順に以下のように計算できます。

```ruby
> 4972 - (-6236 + 4720)
=> 6488
> 52 / (153.0 / 100) ** 2
=> 22.21367849972233
> 1 + 2 * 3 ** 4 - (5 * 6 + 7)
=> 126
> (63 * (17 + 15 * Math.sqrt(5))) / (25 * (7 + 15 * Math.sqrt(5)))
=> 3.1415926538056884
> 2 ** 64 + 3 ** 18
=> 18446744074096972105
```

2 番目の例では、わり算を浮動小数点数として計算するため 153 を `153.0` としています。
代わりに 100 の方を `100.0` にしたり、浮動小数点数への変換関数を使って `153.to_f` や `100.to_f` にしたりしても構いません。

2 番目や 3 番目の例で分かるように、Ruby では通常の数学と同様に、冪乗 (`**`) が最も優先して計算され、次に乗除 (`*`, `/`)、最後に加減 (`+`, `-`) が計算されます。
また、同じ優先順位の場合は左から計算されます。
したがって、例えば 3 番目の例に優先順位を示す括弧を明示的に付けると以下のようになります。

```ruby
> (1 + (2 * (3 ** 4))) - ((5 * 6) + 7)
=> 126
```

さらに 5 番目の例が示すように、Ruby では整数であればどんなに大きな数でもオーバーフローしません。
計算結果がどのくらいの大きさになるのか気にする必要がないので便利ですね!

## 演習問題 2

```ruby
> (-19) / 5
=> -4
> 19 / (-5)
=> -4
> (-19) / (-5)
=> 3
> (-19) % 5
=> 1
> 19 % (-5)
=> -1
> (-19) % (-5)
=> -4
```

予想は当たりましたか?
以下でなぜこのような計算結果になるのか詳しく説明しますが、<u>決して覚える必要はありません</u>。
重要なのは挙動そのものではなく、わり算で負の数が絡むと直感と反する結果になることがあるという事実です。

`a / b` の `b` が正の場合は、 a ÷ b を厳密に計算した値以下の最大の整数を返します。
−19 ÷ 5 は −3.8 であり、これ以下の最大の整数は −4 となので、`(-19) / 5` の結果は `-4` です。

`a` / `b` の `b` が負の場合は、 a ÷ (−b) を厳密に計算した値以上の最小の整数の符号を反転したものを返します。
19 ÷ (−(−5)) は 3.8 で、これ以上の最小の整数は 4 なので、`19 / (-5)` の結果はこれの符号を反転した `-4` です。

`a % b` の結果は、常に `a` − (`a / b`) × `b` です。

負の数の剰余の挙動は言語によって違うことが多いです。
実際、上の挙動は C++ や Java とは異なります。
たまにバグの原因になったりするので、挙動そのものを完璧に覚えておく必要はありませんが、微妙な挙動をすることがあるという事実は頭に留めておきましょう。
負の数を含む剰余はしないようにするというのも、バグをなくす 1 つの手です。

## 演習問題 3

`..` は終点を含みますが、`...` は終点を含みません。
`1..10` は閉区間 [1, 10] を表すのに対し、`1...10` は半開区間 [1, 10) を表すと考えると分かりやすいかもしれません。

半開区間なんていつ使うんだと思うかもしれませんが、プログラミングの世界では、1 から始まる範囲より 0 から始まる範囲の方が圧倒的に多く使います。
そのため、たとえば 10 回繰り返しをしたいときに `0..9` ではなく `0...10` のように、繰り返し回数の 10 をコード中にそのまま書けるのは非常にありがたいです。
この場合は繰り返し回数が明確な数値なのでありがたみが微妙に分かりづらいですが、例えば繰り返し回数が `n` という変数に代入されていたらどうでしょうか。
`0..(n - 1)` よりも `0...n` の方が簡明ですよね。

## 演習問題 4

84697 未満の 2 以上の整数で順に 84697 をわっていき、どれでもわり切れなかったら 84697 は素数です。
そこで、例えば以下のようなプログラムが考えられます。

```ruby
> x = 84697
> res = true
> for i in 2..(x - 1)  # i に 2 から x - 1 までの数字を代入する
>   if x % i == 0      # もし x が i でわり切れたら
>     res = false      # res に false を代入して
>     break            # 繰り返しを終了する
>   end
> end
> if res
>   p "prime"
> else
>   p "not prime"
> end
```

## 演習問題 5

`array[-1]` は `array` の最後の要素を返します。
同様に、`array[-2]` は `array` の最後から 2 番目の要素を返します。
また、問題にはなっていませんでしたが、`array` は 4 つの要素からなり最後から 5 番目の要素は存在しないので、`array[-5]` は `nil` になります。

```ruby
> array = ["first", "second", "third", "fourth"]
> array[-1]
=> "fourth"
> array[-2]
=> "third"
> array[-5]
=> nil
```

この機能がない言語では配列の最後の要素を取得するのに `array[array.length - 1]` などとしなければなりませんが、Ruby なら `array[-1]` で一発です。
ちなみに、配列の最後の要素を取得する関数として `last` というものが用意されているので、`array.last` としても最後の要素が取得できます。

## 演習問題 6

演習問題 5 では `fruits[-1]` で最後の要素が取得できることを学びました。
このことと `fruits[0] = "strawberry"` で 0 番目の要素が変更できたことを踏まえれば、以下のようにすれば最後の要素が変更できます。

```ruby
> fruits[-1] = "strawberry"
> fruits
=> ["apple", "orange", "banana", "peach", "grape", "strawberry"]
```

なお、`fruits.last = "strawberry"` はエラーになります。
これは `last` という関数が最後の値を取得するだけで、それに対応する代入のための関数が用意されていないためです。

配列の特定の位置に要素を挿入するには、`insert` という関数が使えます。

```ruby
> fruits.insert(3, "melon")
> fruits
=> ["apple", "orange", "banana", "melon", "peach", "grape", "strawberry"]
```

これ以外でも `fruits[3, 0] = "melon"` なんて書き方もあります。

配列の特定の要素を削除するには、`delete` を使います。

```ruby
> fruits.delete("orange")
> fruits
=> ["apple", "banana", "melon", "peach", "grape", "strawberry"]
```

配列の要素を逆順にした配列を生成するには、`reverse` が使えます。

```ruby
> new_fruits = fruits.reverse
> new_fruits
=> ["strawberry", "grape", "peach", "melon", "banana", "apple"]
```

なお、`insert` や `delete` は操作された配列自身を変更しますが、`reverse` は逆順の配列を<u>新たに作る</u>関数なので、もともとの配列は変更されません。
逆順にした配列でもとの配列自身を書き換えたい場合は、`reverse` の代わりに `reverse!` を用います。

```ruby
> fruits.reverse!
> fruits
=> ["strawberry", "grape", "peach", "melon", "banana", "apple"]
```

このように、何らかの操作をして新しいものを作る関数があるとき、その操作をした後に自分自身を操作後のものに書き換える関数が `!` を付した名前で用意されていることがよくあります。
`slice` と `slice!` や `uniq` と `uniq!` などがその例です。
他にもあるので調べてみましょう。