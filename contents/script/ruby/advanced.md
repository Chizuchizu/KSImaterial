# Ruby ― 応用編

## 標準出力

標準出力とは、コンソールで実行しているならそこに表示される出力です。
Ruby では、`puts` や `print` などのメソッドで標準出力に文字列を出力できます。
`puts` は文字列の最後が改行でない場合に改行を挿入します。
例えば、以下を実行すると出力に改行が行われません。

```ruby
print "Hello world."
```

`print` で `puts` と同じ出力を得るためには、改行 `\n` を文字列内に付け加える必要があります。

```ruby
print "Hello world.\n"
```

`puts` や `print` は数字を出力することもできます。

```ruby
puts 1
```

ここで注意すべきことは、`1` はあくまで文字列ではないことです。
したがって、以下はエラーになります (基本編でも解説しました)。

```ruby
puts 1 + " yen"
```

以下のようにしましょう。

```ruby
puts 1.to_s + " yen"
```

もしくは、`puts` や `print` は複数個の引数をとれるので、以下のようにしても良いでしょう。

```ruby
print 1," yen\n"
```

基本編でさんざん使った `p` も標準出力に引数の値を出力するメソッドです。
`p` はデバッグなどで値の中身を知りたいときに用い、`puts` や `print` は文字列をメッセージとして出力したいときに用います。
`p` と `puts` とで微妙に出力結果が異なります (詳しくは Ruby のリファレンスマニュアルなどを参照してください)。

```ruby
p "string"
puts "string"
p [1, 2, 3]
puts [1, 2, 3]
```

## 標準入力

標準入力の方法もいろいろとありますが、一番手軽なのは `gets` を使うことです。
`gets` を用いると、Ruby の処理系がキーボードからの入力を待ちます。
キーボードからの入力は Enter を押すことで終了することができます。
詳しくは、以下を実際に実行するのが分かりやすいでしょう。

```ruby
a = gets
print a
```

注意すべきことは、`gets` によって取得されるデータは文字列であるという点です。
したがって、例えば入力された 2 つの整数の和をとるプログラムは、以下のようにする必要があります。

```ruby
a = gets
b = gets
puts a.to_i + b.to_i  # a は文字列, a.to_i は整数
```

## 引数渡し

プログラム実行時に引数を渡すことができます。
まず、次のプログラムを「argv.rb」として保存してください。

```ruby
puts ARGV[0]
```

これはプログラムに渡した引数のうちの初めのものをそのまま出力するプログラムです。
実行すると次のようになります。

```
$ ruby argv.rb hoge
hoge
```

お分かりのように、`ARGV` にはプログラムの書いてあるファイル名より後ろの文字列が配列として記録されます。

```
$ ruby argv.rb hoge piyo
```

この場合、`ARGV` は `["hoge", "piyo"]` となります。

## パイプによる入出力の受け渡し

標準入出力というのは、実は、キーボードによる入出力だけではなく、プログラムからプログラムへのデータのやりとりまで視野に入れた仕組みです。

「keisan.rb」として以下を保存します。

```ruby
puts "keisansuugaku"
```

さらに、「suugaku.rb」として以下を保存します。

```ruby
a = gets
puts a
```

この状態で、次の命令を実行してみましょう。

```
$ ruby keisan.rb | ruby suugaku.rb
```

すると、`keisansuugaku` が出力されると思います。
これは次のようなことが起こっています。

* keisan.rb が標準出力として `keisansuugaku` を出力しようとする
* パイプ `|` があるので、標準出力の先は端末ではなくパイプの向こうにある `suugaku.rb` になる
* suugaku.rb が標準入力 `keisansuugaku` を受け取って `puts` によって出力しようとする
* suugaku.rb の後ろにはパイプが無いので、標準出力は端末になる

これによってプログラム間のデータの受け渡しがスムーズに行われます。

一方で、プログラムに引数を渡す場合、引数として想定されているのは単なるデータではなくファイル名です。
したがって、端末の補完機能がフルに使えます。
引数を入力する際に Tab キーを押してみればその威力が分かると思います。

## モジュール

Ruby ではクラスの他にモジュールというものが存在します (厳密にはクラスがモジュールの一種です)。
こちらは、メソッドの塊のようなものです。
ここでは、デフォルトで定義されているモジュールの中でも特に理系学生の皆さんに必要と思われる `Math` を例に使い方を説明します。
irb で `Math` に登録されているメソッドや定数を実行すると次のようになります。

```ruby
> pi = Math::PI  # Math に保存された定数 PI
=> 3.141592653589793
> Math.sin(pi)   # sin
=> 1.2246467991473532e-16
> Math.cos(pi)   # cos
=> -1.0
```

`sin` や `cos` はよく使うものなので、`Math` をいちいち書くのが面倒になってきます。
そのような場合は、`include` を用いれば以降省略することができます。

```ruby
> include Math
=> Object
> PI       # Math に保存された定数 PI
=> 3.141592653589793
> sin(PI)  # sin
=> 1.2246467991473532e-16
> cos(PI)  # cos
=> -1.0
```

他にも `Math` にはたくさんの機能が用意されています。
リファレンスマニュアルの `Math` の項を見てみましょう。

## fileutils によるファイル操作

プログラミング言語でファイル操作をするというのは一般的には面倒で避けたいものですが、Ruby にはシェルスクリプトでできる程度のファイル操作を行うために用意された fileutils というパッケージが用意されています。
fileutils の機能を使うためには、プログラムの先頭に次の 2 行を書いておきます。

```ruby
require "fileutils"
include FileUtils
```

これで準備は完了です。
例えば、ファイル hoge.txt を piyo.txt という名前でコピーしたい場合には、以下のようにすれば OK です。

```ruby
cp("hoge.txt", "piyo.txt")
```

mv, rm, mkdir なども同様の要領で利用できます。

詳しくはリファレンスマニュアルの `FileUtils` の項へ。

## Ruby 標準機能でのファイル操作

Ruby におけるファイル操作は `File` クラスを用いて行われます。
`File` クラスは実行しているディレクトリにあるファイルをもとにオブジェクトを生成します。
例えば、text.txt に「keisansuugaku」と書き込むスクリプトは次のように書きます。

```ruby
file = File.open("text.txt", "w")  # text.txt をもとにオブジェクトを作成する
file.write("keisansuugaku")        #「keisansuugaku」と書き込む
file.close                         # text.txtを閉じる
```

順を追って説明します。

1 行目の `File.open` は `File.new` としても同じで、`File` オブジェクトを作成する命令です。
後ろの `"w"` は書き込み専用としてファイルを開くことを表します。
第 2 引数に入るコマンドには次のようなものがあります。

* `"r"` … 読み込み専用で開く 
* `"w"` … ファイルの中身を空にしてから書き込み専用で開く 
* `"a"` … 書き込み専用で開く, 書き込みはファイルの末尾から始める
* `"r+"` … 読み書き両用で開く, 書き込みはファイルの先頭からの上書きモードで始める
* `"w+"` … ファイルの中身を空にしてから読み書き両用で開く
* `"a+"` … 読み書き両用で開く, 読み込みは先頭から書き込みは末尾から始める

2 行目の `file.write` は `file` が表すファイルに書き込みをします。
これとは逆に `file.read` とすればファイルの中身を全て文字列にして取得します。
1 行ずつ読み込みたい場合には `file.readline` を用います。

3 行目の `file.close` ではファイルを閉じています。
この作業を怠るとプログラム終了後もファイルが開っぱなしになります。
それで何がまずいのか、直ちにパソコンが壊れるのか、と言われればそのようなことはないのですが、かなり大きいプログラムを書く場合にリソースが足りなくなったり、セキュリティ上の問題が発生したりするので、ファイルは閉じる癖をつけておいて損はありません。

ちなみに、以下のように書くことで明示的に `close` を呼ぶ必要がなくなります。

```ruby
File.open("text.txt", "w") do |file|
  file.write("keisansuugaku")
end
```

好みの問題にもなりますが、こちらの方がファイルの閉じ忘れが防げて良いと思います。

## インターネット接続

Ruby を用いてインターネットに接続することができます。
もちろん、メールのやりとりや SSL 通信などもできてしまいますが、特に HTTP/FTP 通信については簡単にできるパッケージが存在するので、ここではそれに絞って解説しようと思います。

まず、HTTP 通信を簡単に行うためには open-uri というパッケージを読み込む必要があります。
そのために、ソースファイルの先頭に次の 1 行を入れます。

```ruby
require "open-uri"
```

その上でメソッド `open` を使います。
`open` は引数の URL をもとにページのソースを読み込む `StringIO` オブジェクトを生成します。
`StringIO` クラスは `File` クラスとほぼ同様に扱うことができます。

```ruby
file = open("http://www.u-tokyo.ac.jp")
```

これによって、ページのソースをファイルと同じように扱えます。
最後に `close` することもお忘れなく。